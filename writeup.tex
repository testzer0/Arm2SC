\documentclass{article}
\usepackage{amsmath}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[a4paper,bindingoffset=0.2in,%
            left=0.3in,right=0.3in,top=0.3in,bottom=1in,%
            footskip=.25in]{geometry}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\usepackage[scaled=0.8]{FiraMono}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{mathbbol}
\usepackage[makeroom]{cancel}
\usepackage{mathtools}
\usepackage{amssymb} 
\usepackage{xcolor}


\usepackage[inline]{fixme}
\fxsetup{
  status=draft,
  layout=inline, % also try footnote or pdfnote
  theme=color
}
% \definecolor{fxnote}{rgb}{0.8000,0.0000,0.0000}

\fxsetup{theme=color,mode=multiuser}
\FXRegisterAuthor{gp}{agp}{GP}
\FXRegisterAuthor{ab}{aab}{\color{blue}AB}
\newcommand{\gpn}[2][]{\gpnote*{#1}{#2}}
\newcommand{\gp}[1]{\gpnote{#1}}
\newcommand{\abn}[2][]{\abnote*{#1}{#2}}
\newcommand{\ab}[1]{\abnote{#1}}

\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage[ruled,linesnumbered]{algorithm2e}
\newcommand{\var}{\texttt}

\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}

\usepackage{array}
\usepackage{makecell}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}


\title{ARM Memory Rules}
\date{February 2021}

\begin{document}

\maketitle
\section{Syntax for programs (without synchronization instructions)}

\gpwarning{We should start defining macros for most of the notations.}

We use the following syntax for the program.
$$Prog ::= \texttt{ vars: }x^*$$
\vspace{-2em}
$$\qquad\qquad\quad\texttt{procs: }p^*$$
$$p ::= \;\texttt{regs: } \$r^*$$
\vspace{-2em}
$$\qquad\quad\texttt{instrs: }i^*$$
$$i ::= l:\texttt{s}$$
$$\texttt{s} ::= \;x \leftarrow exp$$ 
\vspace{-1.7em}
$$\qquad\;| \$r \leftarrow x $$
\vspace{-1.7em}
$$\qquad\quad\;| \$r \leftarrow exp$$
\vspace{-1.7em}
$$\qquad\qquad\qquad\qquad\quad\enspace|\texttt{if } exp \texttt{ then }i^* \texttt{ else }i^*$$
\vspace{-1.7em}
$$\qquad\qquad\qquad\;|\texttt{while } exp \texttt{ do }i^*$$
\vspace{-1.7em}
$$\qquad\qquad|\texttt{assume } exp$$
\vspace{-1.7em}
$$\qquad\qquad|\texttt{assert } exp$$
\vspace{-1.7em}
$$\quad|\texttt{term}$$
A program $Prog$ first declares a set $\mathcal{X}$ of (shared) variables followed by the code of a set $\mathcal{P}$ of processes. Each process in turn declares a set of registers $\$r$ and it's code in the form of a sequence of instructions denoted by $i^*$. Each such instruction consists of a label $l$ and a statement $s$. A \textit{write} instruction has a statement of the form $x \leftarrow exp$ where $x \in \mathcal{X}$ is a variable and $exp$ is an \textit{expression}. In all the above rules, $exp$ is an expression containing only constants and registers, and no shared variables. A \textit{read} instruction in a process $p \in \mathcal{P}$ is a statement of the form $\$r \leftarrow x$, where $\$r$ is a register in $p$ and $x \in \mathcal{X}$ is a variable. An \textit{assign} instruction in a process $p \in \mathcal{P}$ has the form $\$r \leftarrow exp$, where $\$r$ is a register and $exp$ is an expression. Conditional, iterative, assume and assert instructions, collectively called aci instructions describe the rest of the instructions. The special instruction \texttt{term} is a syntactic sugar to mark the end of the code for the process.
\vspace{-1em}
\section{Definitions for the rules}
We first define a few helper functions:
\begin{itemize}
    \setlength\itemsep{0em}
    \item We refer to the statement corresponding to an instruction \texttt{i} by the function \texttt{stmt(i)}.
    \item For a write instruction $i$ whose statement is of the form $x \leftarrow exp$, or a read instruction $i$ whose statement is of the form $\$r \leftarrow x$, we define $\texttt{var}(i) := x$ to be the variable corresponding to the instruction. For all other types of instructions we define $\texttt{var}(i) = \bot$.
    \item For a instruction $i$ which is of one of the following forms: a write instruction with $\texttt{stmt}(i) = \$r \leftarrow exp$, an assign instruction with $\$r \leftarrow exp$, an aci instruction with either $\texttt{stmt}(i) = \texttt{if } exp \texttt{ then }i^* \texttt{ else }i^*$ or $\texttt{stmt}(i) = \texttt{while } exp \texttt{ do }i^*$, or $\texttt{stmt}(i) = \texttt{assume } exp$, or $\texttt{stmt}(i) = \texttt{assert } exp$, we define the expression occuring in the statement as $\texttt{exp}(i) := exp$. For all other types of instructions we define $\texttt{exp}(i) := \bot$.
    \item For an instruction instance $i$ belonging to the process $p$, we define $\texttt{proc}(i) := p$. Further, we denote the set of instructions of process $p$ by $\mathcal{J}_p$. Also, we denote the statement at which process $p$ begins execution (i.e. the first instruction of the process), by $i_p^{init}$.
    \item For an instruction instance $i \in \mathcal{J}_p$, we denote by $\texttt{next}(i)$ the set of instructions that could immediately follow $i$ in program order. In particular, for an ACI instruction $i$, we denote the set of instructions that could follow $i$ upon evaluation of $\texttt{exp}(i)$ to True, as $\texttt{Tnext}(i)$, and the set of those that could follow on its evaluation to False as $\texttt{Fnext}(i)$.
    \item We define the closest write $CW(\mathbb{c},\mathbb{e}) := \mathbb{e}'$ where $\mathbb{e}'$ is the unique event such that (here and in the rest of the document, an \textit{event} is a single execution instance of an instruction),
    \begin{enumerate}
        \setlength\itemsep{0em}
        \item $\mathbb{e'} \in \mathbb{E}_p^W$ ($\mathbb{E}_p^W$ denotes the set of write events as defined below),
        \item $\mathbb{e'} \prec_\texttt{poloc} \mathbb{e}$ (The poloc program order  $\prec_\texttt{poloc}$ will be defined below),
        \item there is no event $\mathbb{e}''$ such that $\mathbb{e}'' \in \mathbb{E}_p^W$ and $\mathbb{e}' \prec_\texttt{poloc} \mathbb{e}'' \prec_\texttt{poloc} \mathbb{e}$.
    \end{enumerate}
    If no such events exists, we write $CW(\mathbb{e}) := \bot$.
    \item We define by $\mathcal{R}(i)$ the set of registers appearing in $\texttt{exp}(i)$. In the special case that $\texttt{exp}(i) = \bot$, we write $\mathcal{R}(i) := \emptyset$.
\end{itemize}
We define a \textit{configuration} $\mathbb{c}$ as the tuple $\langle\mathbb{E}, \prec, \texttt{ins}, \texttt{status}, \texttt{rf}, \texttt{Prop}\rangle$. Here, $\mathbb{E} \in \mathcal{E}$ is the set of events that have been created up to that point in the program. For any process $p$, we denote by $\mathbb{E}_p$ the events of process $p$ that have been created so far. By $\mathbb{E}^W$ we denote the subset of $\mathbb{E}$ containing precisely the write events. We similarly define $\mathbb{E}^R$, $\mathbb{E}^{ACI}$ and so on. The program order relation $\prec \subseteq \mathbb{E} \times \mathbb{E}$ is an irreflexive partial order that describes for each process $p \in \mathcal{P}$ the order in which events are fetched from the code of $p$. Note that $\mathbb{e}_1 \not\prec \mathbb{e}_2$ if $\texttt{proc}(\mathbb{e}_1) \neq \texttt{proc}(\mathbb{e}_2)$, i.e. if they belong to different processes, and $\prec$ is a total order on each of the $\mathbb{E}_p$ individually. The function $\texttt{status}:\mathbb{E} \mapsto \{\texttt{fetch,init,com}\}$ defines the current status of each event, which is one of fetched, initialized, and committed. The function $\texttt{Prop}: \mathcal{X} \mapsto \mathbb{E}^W \cup \mathcal{E}^\texttt{init}$ defines for each variable the latest value of that variable that has been propagated to the main memory. The function $\texttt{rf}:\mathbb{E}^R \mapsto \mathbb{E}^W \cup \mathcal{E}^\texttt{init}$ defines for each read event $\mathbb{e}$ the event $\texttt{rf}(\mathbb{e})$ from which $\mathbb{e}$ gets its value. 
We introduce a number of dependency relations to help us frame the rules. The \textit{per-location program order} $\prec_\texttt{poloc} \subseteq \mathbb{E} \times \mathbb{E}$ is such that $\mathbb{e}_1 \prec_\texttt{poloc} \mathbb{e}_2$ if and only if $\mathbb{e}_1 \prec \mathbb{e}_2$ and $\texttt{var}(\mathbb{e}_1) = \texttt{var}(\mathbb{e}_2)$. Further, we define the data dependency order $\prec_\texttt{data}$ such that $\mathbb{e}_1 \prec_\texttt{data} \mathbb{e}_2$ if 
\begin{itemize}
    \setlength\itemsep{0em}
    \item $\mathbb{e}_1 \in \mathbb{E}^R \cup \mathbb{E}^A$, i.e. $\mathbb{e}_1$ is a read or assign event.
    \item $\mathbb{e}_2 \in \mathbb{E}^W \cup \mathbb{E}^A \cup \mathbb{E}^{ACI}$, i.e. $\mathbb{e}_2$ is a write, assign or ACI event.
    \item $\mathbb{e}_1 \prec \mathbb{e}_2$
    \item $\texttt{stmt}(\texttt{ins}(\mathbb{e}_1))$ is of the form $\$r \leftarrow x$ or $\$r \leftarrow exp$,
    \item $\$r \in \mathcal{R}(\texttt{ins}(\mathbb{e}_2))$
    \item There is no event $\mathbb{e_3} \in \mathbb{E}^R \cup \mathbb{E}^A$ such that $\mathbb{e}_1 \prec \mathbb{e}_3 \prec \mathbb{e}_2$ is of the form $\$r \leftarrow y$ or $\$r \leftarrow exp'$. That is, we want that $\mathbb{e}_1$ be responsible for "supplying" the data to $\mathbb{e}_2$.
\end{itemize}
Finally, we define the control dependency $\prec_\texttt{ctrl}$ as $\mathbb{e}_1 \prec_\texttt{ctrl} \mathbb{e}_2$ if $\mathbb{e}_1 \in \mathbb{E}^{ACI}$ and $\mathbb{e}_1 \prec \mathbb{e}_2$.\\
We also define the transition relation as a relation $\longrightarrow \subseteq \mathbb{C} \times \mathcal{P} \times \mathbb{C}$. For configurations $\mathbb{c}_1,\mathbb{c}_2 \in \mathbb{C}$ and a process $p \in \mathcal{P}$, we write $\mathbb{c}_1 \xrightarrow{p} \mathbb{c}_2$ to denote that $\langle\mathbb{c}_1,p,\mathbb{c}_2\rangle \in \longrightarrow$.
\vspace{-2em}
\section{Helper predicates for next section}
\begin{center}
 \begin{tabular}{||c | c | c ||} 
 \hline
 \textbf{Predicate} & \textbf{Definition} & \textbf{Meaning} \\ [0.5ex] 
 \hline\hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\ $\texttt{ComCnd}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e'} \in \mathbb{E}$ :\\$((\mathbb{e}' \prec_\texttt{data} \mathbb{e}) \vee (\mathbb{e'} \prec_\texttt{ctrl} \mathbb{e}) \vee (\mathbb{e'} \prec_\texttt{poloc} \mathbb{e}))$ \\ $\implies$ \\ $(\texttt{status}(\mathbb{e'}) = \texttt{com})$} & \makecell{All events preceeding $\mathbb{e}$ in $\prec_\texttt{data}$, $\prec_\texttt{ctrl}$\\ or $\prec_\texttt{poloc}$ have already been commited.}  \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}^W \cup \mathbb{E}^A $ : \\ $\texttt{InitCnd}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^R \cup \mathbb{E}^A$ :\\$(\mathbb{e}' \prec_\texttt{data} \mathbb{e})$ \\ $\implies$ \\ $((\texttt{status}(\mathbb{e'}) = \texttt{init}) \vee (\texttt{status}(\mathbb{e}') = \texttt{com}))$ } & \makecell{All instructions on which $\mathbb{e}$ is data-dependent\\ on have already been initialized. } \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}^\texttt{ACI}$ :\\$\texttt{ValidCnd}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{ACI}$ :\\$((\mathbb{e} \prec \mathbb{e}') \wedge (\nexists \mathbb{e}'' \in \mathbb{E} : \mathbb{e} \prec \mathbb{e''} \prec \mathbb{e'}))$\\$\implies$\\$(((\texttt{Val}(\mathbb{c},\mathbb{e}) = true) \wedge (\texttt{ins}(\mathbb{e'}) = \texttt{Tnext}(\texttt{ins}(\mathbb{e}))))$\\$\vee$\\$((\texttt{Val}(\mathbb{c},\mathbb{e}) = false) \wedge (\texttt{ins}(\mathbb{e}') = \texttt{Fnext}(\texttt{ins}(\mathbb{e})))))$} & \makecell{The instruction that was fetched right\\ after the ACI instruction was consistent\\ with its truth value.} \\
 \hline
 
 \hline
\end{tabular}
\end{center}
% [\texttt{var}(\mathbb{e}) \leftarrow \mathbb{e}]
\section{Rules without synchronization instructions}
\gp{The configurations on the left-hand-side $\mathbb{c}$ and the
  right-hand-side are not bound to each other. I think there is an implicit
  hypothesis throughout that $\mathbb{c} = <E, ...>$. This has to be stated
  somewhere.}\\
\ab{I have now added 2 lines explaining $\mathbb{c}$.}\\
\gp{I understand the intuition, but I'm not sure I understand the formalization
  of $\mathsf{ins}$. Is it a mapping from events to a (set of) immediately
  subsequent instruction(s) in PO?}\\
\ab{\var{ins} just maps events to the instructions they represent (since an event is just one instance of an instruction). Maybe it can be removed from the formalization though, as it doesn't seem to be used further anywhere...}\\  
In this set of rules, we do not include the \texttt{dmb} or \texttt{load/acquire} instructions. Note that in this set of rules, unlike the POWER paper, \texttt{Prop} is a map from variables (and not a process-variable pair) to the set of values. In each of these rules, $\mathbb{c} \equiv \langle \mathbb{E}, \prec, \var{ins}, \var{status}, \var{rf}, \var{Prop} \rangle$ denotes the "current" configuration, and the rule describes one possible way in which this configuration may evolve.
$$ \frac{\mathbb{e} \notin \mathbb{E},\hspace{1em} \prec' = \prec \cup \{ \langle \mathbb{e}', \mathbb{e}\rangle | \mathbb{e}' \in \mathbb{E} \}, \hspace{1em} i \in \texttt{MaxI}(\mathbb{c},p)}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E} \cup \{ \mathbb{e} \}, \prec', \texttt{ins}[\mathbb{e} \leftarrow i], \texttt{status}[\mathbb{e} \leftarrow \texttt{fetch}], \texttt{rf}, \texttt{Prop} \rangle} \texttt{Fetch} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} CW(\mathbb{c},\mathbb{e}) = \mathbb{e}', \hspace{1em} \texttt{status}(\mathbb{e'}) = \texttt{init}}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E},\prec,\texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \mathbb{e}'], \texttt{Prop} \rangle} \texttt{InitReadFromLocal}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} (CW(\mathbb{c},\mathbb{e}) = \bot) \vee (CW(\mathbb{c},\mathbb{e}) = \mathbb{e}' \wedge \texttt{status}(\mathbb{e}') = \texttt{com})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E},\prec,\texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \texttt{Prop}(\texttt{var}(\mathbb{e}))], \texttt{Prop} \rangle} \texttt{InitReadFromProp}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}) }{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle}\texttt{ComRead} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^W, \hspace{1em} \texttt{status} (\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{InitCnd}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{InitWrite} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^W, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}[\texttt{var}(\mathbb{e}) \leftarrow \mathbb{e}]\rangle} \texttt{ComWrite}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^A,\hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{InitCnd}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle\mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{InitAssign}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^A, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{ComAssign} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{ACI}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop} \rangle} \texttt{ComACI} $$
The rule \texttt{Fetch} chooses the next instruction to be executed from the code of a process $p \in \mathcal{P}$. To do this it should be able to select the next instruction $i$ given the configuration $\mathbb{c}$. To do this, we define the function $\texttt{MaxI}(\mathbb{c},p)$ to be the set of instructions that can (intuitively) follow the current one. Formally,
\begin{itemize}
    \setlength\itemsep{0em}
    \item If $\mathbb{E}_p = \emptyset$, then we define $\texttt{MaxI}(\mathbb{c},p) := \{i_p^{init}\}$, i.e. the first instruction to be fetched by $p$ is $i_p^{init}$.
    \item If $\mathbb{E}_p \neq \emptyset$ let $\mathbb{e}' \in \mathbb{E}_p$ be the maximal event in $\mathbb{E}_p$ w.r.t $\prec$ in the configuration $\mathbb{c}$. Define $\texttt{MaxI}(\mathbb{c},p) := \texttt{next}(\texttt{ins}(\mathbb{e}'))$
\end{itemize}
The remaining rules can be explained as follows:
\begin{itemize}
    \setlength\itemsep{0em}
    \item Once a read instruction is fetched, it can be satisfied by reading from either the latest \texttt{po}-previous write instruction (from the same process) that has not yet been propagated to memory, or can be satisfied by reading the value from memory if no such instruction exists. The rule \texttt{InitReadFromLocal} captures the former case, while the rule \texttt{InitReadFromProp} captures the latter. In both cases, we update the status of $\mathbb{e}$ to show that it has been 'initialized', and update \texttt{rf} to indicate the instruction that satisfied it.
    \item Once all \texttt{po}-previous instructions on which $\mathbb{e}$ depends in some way (via a data, control or poloc dependency) have been committed (i.e. been propagated to memory), a satisfied read can be propagated to memory and be committed. This is expressed in the form of the rule \texttt{ComRead}. 
    \item A write instruction can be initialized if all events it is data-dependent on have been initialized. This rule is captured in the form of \texttt{InitWrite}. At this point events of the same thread can read from this write.
    \item  Once all \texttt{po}-previous instructions on which $\mathbb{e}$ depends in some way (via a data, control or poloc dependency) have been committed (i.e. been propagated to memory), an initialized read can be propagated to memory and be committed. At this point events from all threads can read from this write. This forms \texttt{ComWrite}.
    \item The rules for an assign event are similar to that of a write event.
    \item An ACI event undergoes only one state transition after being fetched, i.e. being committed. However, such an event can be committed if and only if it is \textit{valid}, i.e., e.g. the predicted branch turns out to be correct, or a loop is entered, etc. Of course, along with this it must satisfy the \texttt{ComCnd} which says that all events that $\mathbb{e}$ depends upon must have already been committed. This is captured as the rule \texttt{ComACI}.
\end{itemize}
\vspace{-2em}
\section{Syntax for programs (with synchronization instructions)}
We add load and store operations, along with synchronization primitives. Note that loads and stores are still referred to as writes and reads, since they follow the same rules, except that they are also bound by data dependencies.
\vspace{-1em}
$$Prog ::= \texttt{ vars: }x^*$$
\vspace{-2em}
$$\qquad\qquad\quad\texttt{procs: }p^*$$
$$p ::= \;\texttt{regs: } \$r^*$$
\vspace{-2em}
$$\qquad\quad\texttt{instrs: }i^*$$
$$i ::= l:\texttt{s}$$
$$\texttt{s} ::= \;x \leftarrow exp$$ 
\vspace{-1.7em}
$$\qquad\;| \$r \leftarrow x $$
\vspace{-1.7em}
$$\qquad\quad\;| \$r \leftarrow exp$$
\vspace{-1.7em}
$$\qquad\qquad\kern 0.7em| [exp'] \leftarrow exp $$
\vspace{-1.7em}
$$\qquad\kern 1.9em| \$r \leftarrow [exp] $$
\vspace{-1.7em}
$$\qquad\qquad\qquad\qquad\quad\enspace|\texttt{if } exp \texttt{ then }i^* \texttt{ else }i^*$$
\vspace{-1.7em}
$$\qquad\qquad\qquad\;|\texttt{while } exp \texttt{ do }i^*$$
\vspace{-1.7em}
$$\qquad\qquad|\texttt{assume } exp$$
\vspace{-1.7em}
$$\qquad\qquad|\texttt{assert } exp$$
\vspace{-1.7em}
$$\qquad\qquad\qquad\quad\enspace|\texttt{acquire \$r} \leftarrow [exp] $$
\vspace{-1.7em}
$$\qquad\qquad\qquad\kern 2.6em |\texttt{release [exp']} \leftarrow exp$$
\vspace{-1.7em}
$$\qquad|\texttt{dmb.ld}$$
\vspace{-1.7em}
$$\qquad|\texttt{dmb.st}$$
\vspace{-1.7em}
$$\qquad|\texttt{dmb.sy}$$
\vspace{-1.7em}
$$\enspace|\texttt{isb}$$
\vspace{-1.7em}
$$\quad|\texttt{term}$$
\vspace{-3em}
\section{Helper predicates for next section}
\vspace{-1em}
Note that we introduce events corresponding to Dmb.Sy's, Dmb.St's, Dmb.Ld's, Isb's, Load Acquires and Store Releases with the corresponding $\mathbb{E}^\texttt{name}$ being the subset of $\mathbb{E}$ corresponding to \texttt{name} type of instructions.
\gp{Many of the predicates are identical but for the set of events. I would
  define a parametric predicate instead of repeating them many times.}
\begin{center}
 \begin{tabular}{||c | c | c||} 
 \hline
 \textbf{Predicate} & \textbf{Definition} & \textbf{Meaning} \\ [0.5ex] 
 \hline\hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllDmbLds}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{DmbLd}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous Dmb.Ld's have\\ been commited.} \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllDmbSts}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{DmbSt}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous Dmb.St's have\\ been commited.}  \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllDmbSys}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{DmbSy}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous Dmb.Sy's have\\ been commited.} \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllWrites}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^W \cup \mathbb{E}^\texttt{SRel}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous writes (including\\Store Releases) have been commited.} \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllReads}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^R \cup \mathbb{E}^\texttt{LAcq}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous reads (including\\Load Acquires) have been commited.} \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllSyncs}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{DmbSy} \cup \mathbb{E}^\texttt{Isb}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$}  & \makecell{All po-previous Dmb.Sy's and\\ Isb's have been commited.} \\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}^\texttt{LAcq}$ :\\$\texttt{AllSRels}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e} \in \mathbb{E}^\texttt{SRel}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous Store Releases\\ have been commited.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}^R \cup \mathbb{E}^\texttt{LAcq}$ :\\$\texttt{AllLAcqInit}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^\texttt{LAcq}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies ((\texttt{status}(\mathbb{e'}) = \texttt{init}) \vee (\texttt{status}(\mathbb{e'}) = \texttt{com})))$} & \makecell{All po-previous Load Acquires\\ have been initialized.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllLAcqs}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall\mathbb{e}' \in \mathbb{E}^\texttt{LAcq}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies \texttt{status}(\mathbb{e}') = \texttt{com}))$} & \makecell{All po-previous Load Acquires \\have been committed.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllStoreInit}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^W \cup \mathbb{E}^\texttt{SRel}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies ((\texttt{status}(\mathbb{e'}) = \texttt{init}) \vee (\texttt{status}(\mathbb{e'}) = \texttt{com})))$} & \makecell{All po-previous write instructions\\ (including Store Releases) have been\\ initialized}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllLoadInit}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^R \cup \mathbb{E}^\texttt{LAcq}$ :\\$((\mathbb{e'} \prec \mathbb{e}) \implies ((\texttt{status}(\mathbb{e'}) = \texttt{init}) \vee (\texttt{status}(\mathbb{e'}) = \texttt{com})))$} & \makecell{All po-previous read instructions\\ (including Load Acquires) have been\\ initialized}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllMemInit}(\mathbb{c},\mathbb{e})$} & \makecell{$\texttt{AllLoadInit}(\mathbb{c},\mathbb{e}) \wedge \texttt{AllStoreInit}(\mathbb{c},\mathbb{e})$} & \makecell{All po-previous instructions that\\ access memory have been\\ initialized.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllMem}(\mathbb{c},\mathbb{e})$} & \makecell{$\texttt{AllWrites}(\mathbb{c},\mathbb{e}) \wedge \texttt{AllReads}(\mathbb{c},\mathbb{e})$} & \makecell{All po-previous instructions that\\ access memory have been\\ committed.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}$ :\\$\texttt{AllBarriers}(\mathbb{c},\mathbb{e})$} & \makecell{$\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}) \wedge \texttt{AllDmbSts}(\mathbb{c},\mathbb{e}) \wedge \texttt{AllSyncs}(\mathbb{c},\mathbb{e})$} & \makecell{All po-previous barriers\\have been committed.}\\
 \hline
 \makecell{$\mathbb{e} \in \mathbb{E}^W \cup \mathbb{E}^A $ : \\
 $\texttt{InitCnd}(\mathbb{c},\mathbb{e})$} & \makecell{$\forall \mathbb{e}' \in \mathbb{E}^R \cup \mathbb{E}^A$ :\\$(\mathbb{e}' \prec_\texttt{data} \mathbb{e}) \vee (\mathbb{e}' \prec_\texttt{addr} \mathbb{e})$ \\ $\implies$ \\ $((\texttt{status}(\mathbb{e'}) = \texttt{init}) \vee (\texttt{status}(\mathbb{e}') = \texttt{com}))$ } & \makecell{All instructions on which $\mathbb{e}$ is\\ dependent on have\\ already been initialized. } \\
 \hline
 \hline
\end{tabular}
\end{center}
\section{Rules with synchronization conditions}
$$\frac{\mathbb{e} \in \mathbb{E}, \hspace{1em} \prec' = \prec \cup \{\langle\mathbb{e}',\mathbb{e}\rangle | \mathbb{e}' \in \mathbb{E}_p\}, \hspace{1em} i \in \texttt{MaxI}(\mathbb{c},p)}{\mathbb{c} \xrightarrow{p} \langle \mathbb{E} \cup \mathbb{e}, \prec', \texttt{ins}[\mathbb{e} \leftarrow i], \texttt{status}[\mathbb{e} \leftarrow \texttt{fetch}], \texttt{rf}, \texttt{Prop}\rangle}\texttt{Fetch}$$
$$\mspace{-150mu}\mathbb{e} \in \mathbb{E}^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} $$
\vspace{-1.2em}$$ \frac{\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLacqInit}(\mathbb{c},\mathbb{e}), \hspace{1em} \mathbb{e}' = CW(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{status}(\mathbb{e}') = \texttt{init}}{\mathbb{c} \xrightarrow{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \mathbb{e}'], \texttt{Prop} \rangle} \texttt{InitReadFromLocal}$$
$$\mspace{-150mu}\mathbb{e} \in \mathbb{E}^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} $$
\vspace{-1.2em}$$ \frac{\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLacqInit}(\mathbb{c},\mathbb{e}), \hspace{1em} (CW(\mathbb{c},\mathbb{e}) = \bot) \vee (CW(\mathbb{c},\mathbb{e}) = \mathbb{e}' \wedge \texttt{status}(\mathbb{e}') = \texttt{com})}{\mathbb{c} \xrightarrow{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \texttt{Prop}(\texttt{Var}(\mathbb{c},\mathbb{e}))], \texttt{Prop}\rangle} \texttt{InitReadFromProp}$$
$$\mspace{-150mu}\mathbb{e} \in \mathbb{E}^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} $$
\vspace{-1.2em}$$ \frac{ \texttt{AllSRels}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLacqInit}(\mathbb{c},\mathbb{e}), \hspace{1em} \mathbb{e}' = CW(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{status}(\mathbb{e}') = \texttt{init}}{\mathbb{c} \xrightarrow{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \mathbb{e}'], \texttt{Prop} \rangle} \texttt{InitLAcqFromLocal}$$
$$\mspace{-150mu}\mathbb{e} \in \mathbb{E}^R, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSRels}(\mathbb{c},\mathbb{e}), $$
\vspace{-1.2em}$$ \frac{\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLacqInit}(\mathbb{c},\mathbb{e}), \hspace{1em} (CW(\mathbb{c},\mathbb{e}) = \bot) \vee (CW(\mathbb{c},\mathbb{e}) = \mathbb{e}' \wedge \texttt{status}(\mathbb{e}') = \texttt{com})}{\mathbb{c} \xrightarrow{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}[\mathbb{e} \leftarrow \texttt{Prop}(\texttt{Var}(\mathbb{c},\mathbb{e}))], \texttt{Prop}\rangle} \texttt{InitLacqFromProp}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^R \cup \mathbb{E}_p^\texttt{LAcq}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle}\texttt{ComReadOrLacq} $$
$$ \kern -4em\mathbb{e} \in \mathbb{E}_p^W, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{InitCnd}(\mathbb{c},\mathbb{e}), $$
\vspace{-1.2em}$$\frac{\texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em}\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLAcqs}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSts}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{InitWrite}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{SRel}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{InitCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllMem}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSts}(\mathbb{c},\mathbb{e}) }{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{InitSRel}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^W \cup \mathbb{E}_p^\texttt{SRel}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}[\texttt{var}(\mathbb{e}) \leftarrow \mathbb{e}]\rangle} \texttt{ComWriteOrSRel}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{DmbSy}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllMem}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllBarriers}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{ComDmbSy} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{Isb}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllMemInit}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSys}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{ComIsb} $$
\ab{The \var{ComIsb} rule is somehow wrong. In the Flat model they say "all \var{po}-previous memory instructions have fully defined memory footprints. This corresponds just to \var{fetch} in our model [the rule lists \var{init} instead]. Or does it? what about a dependency of type $r \xrightarrow[]{addr,po} w \xrightarrow[]{po} \var{isb}$? Here for $w$'s "memory footprint" to be defined do we need $r$ to be \var{init}ed? This could complicate stuff.}\\
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{DmbLd}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllReads}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSys}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{ComDmbLd} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{DmbSt}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllWrites}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSys}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop} \rangle} \texttt{ComDmbSt} $$
$$\frac{\mathbb{e} \in \mathbb{E}_p^\texttt{ACI}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{ValidCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{ComACI} $$
We explain the above rules as thus:
\begin{itemize}
    \setlength\itemsep{0em}
    \item The \texttt{Fetch} rule is the same as before.
    \item We need the following pre-conditions to hold for initializing (satisfying) a read event $\mathbb{e}$ (from either local uncommitted events or memory):
        \begin{enumerate}
            \setlength\itemsep{0em}
            \item For all events $\mathbb{e}'$ that are poloc-predecessors of $\mathbb{e}$, $\mathbb{e}'$ must have been initialized.
            \item All Dmb.Sy, Isb and Dmb.Ld instructions that are po-predecessors of $\mathbb{e}$ have been committed.
            \item All po-preceeding Load Acquire instructions have been initialized, i.e. entirely satisfied.
        \end{enumerate}
    \item The rule for initializing a Load Acquire is similar to that of a read, but with the extra condition that all po-previous Store Releases have been committed.
    \item To initialize a write, along with an \texttt{InitCnd} that we had previously, we need the following conditions to hold:
    \begin{enumerate}
        \setlength\itemsep{0em}
        \item All po-previous Dmb.Sy, Isb, Dmb.Ld, Dmb.St, and Load Acquire instructions have been committed.
        \item All po-previous store (writes and store releases) instructions have been initiated.
    \end{enumerate}
    \item To initialize a store release, the required conditions are almost the same as for writes, with the difference that instead of just load acquires, all po-previous memory access instructions have been committed.
    \item The condition for committing a write or store release, is similar to before, but with the added condition that all po-previous synchronization instructions(Dmb.Sy and Isb) are committed.
    \item All ACI and synchronization instructions have only one transition: from fetch to commit. Across all of them, the \texttt{ComCnd} and \texttt{ValidCnd} are common conditions, as is the condition that all Dmb.Sy's have been committed (for ACI's and Dmb.Sy's we also need po-previous Isb's to have been committed). Apart from this,
    \begin{enumerate}
        \setlength\itemsep{0em}
        \item For Dmb.Sy's we need all po-previous memory access instructions to have committed.
        \item For Isb's we need all po-previous memory access instructions to have been initialized.
        \item For Dmb.Ld's we need all po-previous load (read and load acquire) instructions to have been committed.
        \item For Dmb.St's we need all po-previous stores (write and store release) instructions to have been committed.
    \end{enumerate}
\end{itemize}
\textbf{Assign instructions.} The ARM developer manual or the Flat model do not explicitly handle assign instructions. We can instead imagine it as writing the value of $exp$ to a new variable $z$ which is later read into the register $\$r$. Since this variable is never used by any other process, we can construct a rule for this assign statement by simply merging the rules for read and write. Since \var{AllLacqInit} is a weaker condition than \var{AllLacqs}, we can simply use the predicates for the write event. One must, however, keep in mind that this is a derived rule.\\
\ab{There is one hairy point about \var{Assign}s: are they allowed to be reordered with \var{dmb.sy}/\var{isb}'s? The models say \var{dmb.sy} only stops memory-access instructions from being reordered with it; and technically an \var{assign} only goes from registers to registers, so it doesn't access memory...}\\
\ab{Also, it may be helpful to verify once that this rule is correct. I just assumed it to be a write to a private variable + read into register merged into a single instruction.}\\
$$ \kern -4em\mathbb{e} \in \mathbb{E}_p^{A}, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{fetch}, \hspace{1em} \texttt{InitCnd}(\mathbb{c},\mathbb{e}), $$
\vspace{-1.2em}$$\frac{\texttt{AllSyncs}(\mathbb{c},\mathbb{e}), \hspace{1em}\texttt{AllDmbLds}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllLAcqs}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllDmbSts}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{init}], \texttt{rf}, \texttt{Prop}\rangle} \texttt{InitAssign}$$
$$\frac{\mathbb{e} \in \mathbb{E}_p^A, \hspace{1em} \texttt{status}(\mathbb{e}) = \texttt{init}, \hspace{1em} \texttt{ComCnd}(\mathbb{c},\mathbb{e}), \hspace{1em} \texttt{AllSyncs}(\mathbb{c},\mathbb{e})}{\mathbb{c} \xrightarrow[]{p} \langle \mathbb{E}, \prec, \texttt{ins}, \texttt{status}[\mathbb{e} \leftarrow \texttt{com}], \texttt{rf}, \texttt{Prop}[\texttt{var}(\mathbb{e}) \leftarrow \mathbb{e}]\rangle} \texttt{ComAssign}$$
\section{Proof of equivalence to the ARMv8 Model}
We give here the proof of equivalence of the above model to the ARMv8 model, as found in section B2.3 of the ARM developer manual. There are two main conditions for the equivalence to hold: the \textcolor{red}{local ordering constraints} and the \textcolor{blue}{external ordering constraints}. We do not take into account tag reads or tag writes since our model does not include them. The local ordering constraints consist of the following:
\begin{itemize}
    \item \textcolor{violet}{Constraints due to local-write successors.} These correspond to write-write pairs related by $\prec_\texttt{poloc}$. Consider any valid execution under our model, and consider two write events $\mathbb{e}_1 \prec_\var{poloc} \mathbb{e}_2$. Note that $\mathbb{e}_1$ is always committed before $\mathbb{e}_2$, and because reads can read only from po-previous writes, an execution in which $\mathbb{e}_1$ is initialized after $\mathbb{e}_2$ is functionally equivalent to one where $\mathbb{e}_1$ is initialized just before $\mathbb{e}_2$ (because reads that occur po-between the two events will anyway read from $\mathbb{e}_1$ in our model; and for those after $\mathbb{e}_2$ this leads to a functionally same scenario). Hence, reachability is preserved by our model for this rule.
    \item \textcolor{violet}{Dependency ordered before relations are preserved.} This consists of the \texttt{rf},\texttt{addr},\texttt{data} and \texttt{ctrl} dependencies. The first follows immediately from the definition of $CW$. The othersIn our formulation of the syntax of concurrent programs \texttt{addr} and \texttt{data} dependencies both are part of $\prec_\texttt{data}$ (since we represent loads by $\$r \longleftarrow x$ and stores by $x \longleftarrow \$r$). Then this follows from \texttt{InitCnd} which appears in all initialization rules for writes, and the definition of $CW$ for reads. The \texttt{AllSyncs} predicate which appears in all synchronization rules takes care of the fourth.
    \item \textcolor{violet}{Atomic-ordered-before relations are preserved}. These refer to the ordering between \texttt{SRel} and \texttt{LAcq} instructions: 1) the per-loc ordering between \texttt{LAcq-SRel} pairs must be maintained and 2) the \textcolor{red}{local read successor} relation between a \texttt{SRel} and a \texttt{LAcq} must be preserved. The \texttt{AllMem} predicate in \texttt{InitSRels} takes care of (1), and \texttt{AllSRel} in the \texttt{InitLacq}-rules takes care of (2).
    \item  \textcolor{violet}{Barrier-ordered-before relations are preserved.} These relations are further divided into the following:
    \begin{enumerate}
        \setlength\itemsep{0em}
        \item \textcolor{green}{The ordering between two events separated by a dmb.full}. The \texttt{AllSyncs} predicate takes care of this, along with the predicates of the \texttt{ComDmbSy} and \texttt{ComIsb} rules.
        \item \textcolor{green}{The ordering between two events that form an release-acquire pair}. The release-acquire pairs are said to be like two halves of a \texttt{dmb.full}. The \texttt{AllSRels} predicate of \texttt{LAcqInit} handles this.
        \item \textcolor{green}{The ordering between a read-event pair where the read is po-before a \texttt{dmb.ld} which is po-before the event}. The \texttt{AllReads} condition of \texttt{ComDmbLd} combined with \texttt{AllDmbLds} in all of the \texttt{init} rules ensures that this constraint holds.
        \item \textcolor{green}{The ordering between a \texttt{LAcq} and po-later event is preserved}. The \texttt{AllLacqInit} (and the \texttt{AllLacqs} in case of \texttt{InitWrite}) that appears in all the \texttt{init} rules takes care of this.
        \item \textcolor{green}{The ordering between a write-write pair where the first write is po-before a \texttt{dmb.st} which is po-before the second write}. First note that the \texttt{AllWrites} predicate in \texttt{ComDmbSt} ensures that the write is committed before the \texttt{dmb.st}. Further, the \texttt{AllDmbSts} predicate of \texttt{InitWrite} and \texttt{InitSRel} ensure that the \texttt{dmb.st} is committed before the second write is initialized.
        \item \textcolor{green}{The ordering between a release and a \textit{preceeding} event is preserved}. This is ensured by the \texttt{AllMem} predicate in \texttt{InitSRel}.
    \end{enumerate}
    \item \textcolor{violet}{The transitive closure of the above must hold}. Since we showed that each of the above orderings holds individually, the transitive closure follows easily.
\end{itemize}
Next we tackle the proof of the \textcolor{blue}{global ordering constraints}. We choose the \textcolor{red}{ordered-before} formulation of the external ordering constraints as presented in ARM's manual. An event $\mathbb{e}_1$ is \textit{ordered-before} another event $\mathbb{e}_2$ if and only if at least one of the following hold:
\begin{itemize}
    \item $\mathbb{e}_1$ is \textit{observed by} (i.e. is read by) $\mathbb{e}_2$, or
    \item $\mathbb{e}_1$ is \textit{locally ordered} before $\mathbb{e}_2$, or
    \item There exists an event $\mathbb{e}_3$ such that $\mathbb{e}_1$ is ordered before $\mathbb{e}_3$ which in turn is ordered before $\mathbb{e}_2$ (transitive closure).
\end{itemize}
Then, the \textcolor{red}{external ordering constraint} requires that there are no cycles in the ordered-before relation, i.e. that all processors see a consistent view of the order. Note that, denoting the ordered-before relation by $\prec_\texttt{ob}$, if $\mathbb{e}_1 \prec_\texttt{ob} \mathbb{e}_2$ where $\mathbb{e}_1$ and $\mathbb{e}_2$ belong to different processes, then since in our model the memory's contents can be overwritten by newer events but not "uncovered", $\mathbb{e}_2$ "covers" $\mathbb{e}_1$ and hence the first event cannot be read after that by any events: this is because remote reads see a more recent version of the memory, while local reads either read from the main memory which has the same effect, or from a local read which is \textit{more recent} than the main memory which is in turn more recent than $\mathbb{e}_1$. Thus, the only way cycles can enter the $\prec_\texttt{ob}$ ordering is if there is a cycle in the local ordering, which as established above is not possible.\\
Thus we conclude that \textcolor{red}{every valid execution under our model (which we call ARM') corresponds to a valid execution under ARM}.\\
Further, note that \textit{every predicate that occurs as a part of our rules follows from one of the conditions of ARM}. This means that since any valid execution under ARM satisfies exactly these predicates, \textcolor{blue}{any valid execution under ARM satisfies each of these rules}. Thus, every execution under ARM is valid under ARM'.\\
Using the above two results, we conclude that $\boxed{ARM \equiv ARM'}$, completing the proof of equivalence.
\section{Context Bound Model Checking for ARM}
%TODO
% Also explain stuff. Flesh out some details later [TODO]
\section{Code-to-code translation for reduction to SC (for the simple model) }
For the sake of performing context-bound model checking, we next define the scheme for the code-to-code translation.
\subsection{Scheme for the first part of model (without synchronization instructions)}
Our translation scheme translates a program $Prog$ into a program $Prog^\clubsuit$ using the map function $\llbracket\cdot\rrbracket_K$. Let $\mathcal{P}$ and $\mathcal{X}$ be the set of processes and shared variables in our program. Then, the map $\llbracket\cdot\rrbracket_K$ replaces the variables of $Prog$ by $|\mathcal{P}|\cdot K$ copies of the set $\mathcal{X}$, along with a finite set of finite data structures defined below. Below, the function $\texttt{gen}$ takes in a finite set and returns a randomly chosen element of the set.\\
$$\llbracket Prog \rrbracket_K \myeq \texttt{ vars: }x^* \hspace{0.5em} \langle \texttt{addvars} \rangle_K$$
\vspace{-2em}
$$\qquad\qquad\qquad\qquad\kern 6.5em\texttt{procs: }(\llbracket p \rrbracket_K)^* \kern 0.5em \langle \texttt{initProc} \rangle_K \kern 0.5em \langle \texttt{verProc} \rangle_K$$
$$\llbracket p \rrbracket_K \myeq \;\texttt{regs: } \$r^*$$
\vspace{-2em}
$$\qquad\qquad\qquad\texttt{instrs: } (\llbracket i \rrbracket_K^p)^*$$
$$\llbracket i \rrbracket_K^p \myeq l: \kern 0.5em \langle \texttt{activeCnt} \rangle_K^p \kern 0.5em \llbracket \texttt{s} \rrbracket_K^p \kern 0.5em \langle \texttt{closeCnt} \rangle_K^p$$
$$\llbracket x \leftarrow exp \rrbracket_K^p \myeq \llbracket x \leftarrow exp \rrbracket_K^\texttt{p,Write}$$ 
\vspace{-1.2em}
$$\llbracket \$r \leftarrow x \rrbracket_K^p \myeq \llbracket \$r \leftarrow x \rrbracket_K^\texttt{p,Read}$$
\vspace{-1.2em}
$$\llbracket \$r \leftarrow exp \rrbracket_K^p \myeq \llbracket \$r \leftarrow exp \rrbracket_K^\texttt{p,Assign} $$
\vspace{-1.2em}
$$\llbracket \texttt{if } exp \texttt{ then }i^* \texttt{ else }i^* \rrbracket_K^p \myeq \texttt{if } exp \texttt{ then } (\llbracket i  \rrbracket_K^p)^* \texttt{ else } (\llbracket i \rrbracket_K^p)^*; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{while } exp \texttt{ do }i^* \rrbracket_K^p \myeq \texttt{while } exp \texttt{ do } (\llbracket i \rrbracket_K^p)^*; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{assume } exp \rrbracket_K^p \myeq \texttt{assume } exp ; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{assert } exp \rrbracket_K^p \myeq \texttt{assert } exp ; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket\texttt{term}\rrbracket_K^p \myeq \texttt{term}$$
\vspace{-1.2em}
$$\langle \var{addvars} \rangle_K \myeq \mu(|\mathcal{X}|,K), \mu^{init}(|\mathcal{X}|,K), \nu(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \quad\var{iR}(|\mathcal{P}|,|\mathcal{X}|), \var{cR}(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \quad\var{iW}(|\mathcal{P}|,|\mathcal{X}|), \var{cW}(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \qquad\quad\var{iReg}(|\mathcal{P}|,|\mathcal{R}|), \var{cReg}(|\mathcal{P}|,|\mathcal{R}|),$$
$$ \quad\;\var{ctrl}(|\mathcal{P}|), \var{active}(K), cnt$$
\vspace{-1.2em}
$$\langle \texttt{activeCnt} \rangle_K^p \myeq \texttt{assume}(\texttt{active}(\texttt{cnt}) = p)$$
\vspace{-1.2em}
$$\langle \texttt{closeCnt} \rangle_K^p \myeq cnt \leftarrow cnt + \texttt{gen}([0,\cdots,K-1]);$$
\vspace{-1.7em}
$$ \texttt{assume}(cnt \leq K)$$
\vspace{-1.2em}
$$ \langle \texttt{control} \rangle_K^p \myeq \texttt{ctrl}(p) \leftarrow \texttt{ctrl}(p) + \texttt{gen}(0,\cdots,K-1);$$
\vspace{-1.7em}
$$ \texttt{assume}(\texttt{ctrl}(p) \leq K)$$
\subsection{Data Structures (for the model without synchronization)}
We denote by $\mathcal{D}$ the domain of all possible values of expressions and variables. Our simulation maintains, as described above, a finite set of finite data structures. We explain each in turn. First, for each context $k$, we store the ID of the active process $p$ in the context $k$, using the mapping $\texttt{active}: [1,\cdots,K] \mapsto \mathcal{P}$. The mapping $\mu^{init}: \mathcal{X} \times [1,\cdots,K] \mapsto \mathcal{D}$ maintains, for each variable $x$ and context $k$ the last value of the variable $x$ that has been propagated to memory by any process \textit{upto the beginning of context $k$}. We also define the mapping $\mu: \mathcal{X} \times [1,\cdots,K] \mapsto \mathcal{D}$ as the counterpart of the above mapping that actually changes (gets updated) through the course of context $k$, i.e. at any given point in time covered by context $k$, $\mu(x,k)$ gives the latest value of variable $x$ propagated to memory until that point.  Further, the mapping $\nu: \mathcal{P} \times \mathcal{X} \mapsto \mathcal{D}$ denotes for each process $p$ and variable $x$ the latest value that has been written to $x$ by $p$. We also maintain the maps $$\texttt{iW}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K]$$
$$\texttt{cW}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K]$$
$$\texttt{iR}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K]$$
$$\texttt{cR}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K]$$
The first map indicates, for each process $p$ and variable $x$, the latest context in which a write on $x$ has been initialized by $p$. Similarly, the second one indicates for each such pair the latest context in which a write was committed by $p$; and the third indicates the latest context in which a read of $x$ was initialized by $p$. Similarly, we define $\var{cR}$ for committing reads. It must be noted that a read is not propagated to other processes. The only purpose of seprately initializing and committing them is for a scenario like this, consider a dependency $w_1 \xrightarrow[]{\var{rf}} r \xrightarrow[]{\var{data}} w_2$. Suppose the \var{init} times of the three are $1,2,3$ respectively, with $w_1$ committed only at $5$. We need to ensure that $w_2$ is not committed before $5$, but we would like to consider only immediate dependencies. Thus it is more convenient to assign $r$ a commit timestamp $\geq 5$, so that we can impose the constraint saying "$w_2$ commits after whatever time $r$ commits".\\
Since registers are shared among all processes, we need to define special mappings for them. Thus we define $\var{iReg}: \mathcal{R} \mapsto [1,\cdots,K]$ which captures for each register $\$r$ the initializing context of the latest read or assign event loading a value to $\$r$. Similarly $\var{cReg}: \mathcal{R} \mapsto [1,\cdots,K]$ captures for each register $\$r$ the commiting context of the latest read or assign event loading a value to $\$r$. We also extend this to expressions, by defining $\var{iReg}(exp) = \max \{\var{iReg}(\$r) | \$r \in \mathcal{R}(exp)\}$. Similarly we extend the other two definitions to expressions.\\
Finally, the mapping $\var{ctrl}: \mathcal{P} \mapsto [1,\cdots,K]$ gives for each process $p$ the committing context of the latest \var{aci} event in $p$. The variable $cnt$ tracks the current context.\\
The function \var{gen} is assumed to return, given a set $S$, a random element of $S$.
\subsection{The initializing process}
We next present the algorithm $\langle \var{initProc} \rangle_K$.\\
\begin{algorithm}[H]
  \SetAlgoLined
  \For{$p \in \mathcal{P} \wedge x \in \mathcal{X}$}{
    $\var{iR}(p,x) \gets 1$\; 
    $\var{iW}(p,x) \gets 1$\;
    $\var{cW}(p,x) \gets 1$\;
    $\var{cR}(p,x) \gets 1$\;
    $\nu(p,x) \gets 0$\;
    $\mu(p,x,1) \gets 0$\;
    \For{$k \in [2,\cdots,K]$}{
        $\mu^{init}(p,x,k) \gets \var{gen}(\mathcal D)$\;
        $\mu(p,x,k) \gets \mu^{init}(p,x,k)$\;
    }
  }
  \For{$p \in \mathcal{P}$}{
    $\var{ctrl}(p) \gets 1$\;
  }
  \For{$\$r \in \mathcal{R}$}{
    $\var{iReg}(p) \gets 1$\;
    $\var{cReg}(p) \gets 1$\;
  }
  \For{$k \in [1,\cdots,K]$}{
    $\var{active}(k) \gets \var{gen}([1,\cdots,K])$\;
  }
  $cnt \gets 1$\;
  \caption{Algorithm $\langle \var{initProc} \rangle_K$.}
\end{algorithm}
The initial process's job is to initialize all the data structures. We assume that in the beginning all variables are assigned the value $0$. If needed we can replace this by a symbolic variable depicting all possible values. The structures which record contexts are all initialized to $1$, since that is the earliest context possible. We also assign to each context a randomly chosen active process.
\subsection{Write instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iW}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cW} \gets \var{cW}(p,x)$\;
  $\var{cW}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  //\var{Check}\\
  $\var{assume}(\var{iW}(p,x) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iW}(p,x)) = p)$\;
  $\var{assume}(\var{iW}(p,x) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{iW}(p,x))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{max}(\var{old-cW},\var{cReg}(exp),\var{cR}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\mu(x,\var{cW}(p,x)) \gets exp$\;
  $\nu(p,x) \gets exp$\;
  \caption{$\llbracket x \leftarrow exp\rrbracket_K^{p,\var{Write}}$}
\end{algorithm}
The above listing shows how write instructions are handled. First, we guess the contexts in which the write will be initialized and committed respectively. Next, we perform a set of sanity checks to ensure that the write conforms to the rule \var{InitWrite}: line 6 checks that the write is initialized after the current context (when it is fetched); line 7 ensures that $p$ is the active process in that context. We then make sure that \var{InitCnd} is satisfied in line 8. Further, the write must be initialized before committed, as expressed in line 9. Finally, we must ensure that the write is committed not before any \var{poloc}-preceeding write or read, and also not before any \var{po}-previous aci instruction or before any instruction which supplies the data for this write. That is expressed in line 10. Then, we update the new values of the global values of $x$ in the respective context, and the latest local value of $x$.
\subsection{Read Instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iR}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cR} \gets \var{cR}(p,x)$\;
  $\var{cR}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{iReg}(\$r) \gets \var{iR}(p,x)$\;
  $\var{cReg}(\$r) \gets \var{cR}(p,x)$\;
  //\var{Check}\\
  $\var{assume}(\var{iR}(p,x) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iR}(p,x)) = p)$\;
  $\var{assume}(\var{iR}(p,x) \geq \var{iW}(p,x))$\;
  $\var{assume}(\var{cR}(p,x) \geq \var{iR}(p,x))$\;
  $\var{assume}(\var{active}(\var{cR}(p,x)) = p)$\;
  $\var{assume}(\var{cR}(p,x) \geq \var{max}(\var{old-cR},\var{cW}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  \uIf{$\var{iR}(p,x) < \var{cW}(p,x)$}{
    $\$r \gets \nu(p,x)$\;
  }
  \Else{
    $\$r \gets \mu(x,\var{iR}(p,x))$\;
  }
  \caption{$\llbracket \$r \leftarrow x\rrbracket_K^{p,\var{Read}}$}
\end{algorithm}
As for writes, we start by guessing the contexts in which the read is initialized and committed. We then perform some sanity checks in the lines 8-14, which we explain next. Line 8 checks that the read is initialized only after being fetched (after or in the current context). Lines 9 and 12 ensure that $p$ is the active process during the initialization and commit of the read. Line 10 ensures that the read is initialized after the closest po-before write is; this is needed due to the model. Line 11 expresses that the read is committed no earlier than it is initialized. Further, we need that the read is committed no earlier than a read/write that is \var{poloc}-before it, or any \var{aci} instruction that is \var{po}-before it. This is expressed in line 13. If the read is initialized before the closest \var{po}-before write (say $w$) is committed, then we must follow the rule \var{InitReadFromLocal}, as dictated by line 16. Otherwise, the global memory is at least as up-to-date, and we must use the rule \var{InitReadFromProp} to read from it. This is captured by the update of rule 18. 
\subsection{Assign Instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iReg}(\$r) \gets \var{gen}([1,\cdots,K])$\;
  $\var{cReg}(\$r) \gets \var{gen}([1,\cdots,K])$\;
  //\var{Check}\\
  $\var{assume}(\var{iReg}(\$r) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iReg}(\$r)) = p)$\;
  $\var{assume}(\var{iReg}(\$r) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{active}(\var{cReg}(\$r)) = p)$\;
  $\var{assume}(\var{cReg}(\$r) \geq \var{iReg}(\$r))$\;
  $\var{assume}(\var{cReg}(\$r) \geq \var{max}(\var{cReg}(exp),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\$r \gets exp$\;
  \caption{$\llbracket \$r \leftarrow exp\rrbracket_K^{p,\var{Assign}}$}
\end{algorithm}
We first guess the initializing and commiting context of the assign statement. Then we run through a few sanity checks that we now describe. We first check at line 4 that the statement is initialized only after it is fetched in the current context $cnt$. We also want that the statement only be committed no earlier than it is initialized; this is captured by line 9. We further need the process $p$ to be active in both the contexts responsible for initialization and commit: this is expressed in lines 6 and 8. Since an assign statement can be initialized only after the statements it is dependent on (via \var{data}), we have line 7 which is \var{InitCnd}. Finally, the statement cannot be committed any earlier than a statement it depends on, or any \var{po}-preceeding aci statement. This corresponds to line 10. The update step is simple: we just record the new value of the register $\$r$.
\subsection{Verifying process}
\begin{algorithm}[H]
  \SetAlgoLined
  \For{$p \in \mathcal{P} \wedge x \in \mathcal{X} \wedge k \in [1,\cdots,K-1]$}{
    $\var{assume}(\mu(p,x,k) = \mu^{init}(p,x,k+1))$\;
  }
  \If{$l$ is reachable}{
    $error$\;
  }
  \caption{$\langle \var{verProc} \rangle_K$.}
\end{algorithm}
The verifying process simply makes sure that the modifications to global state by a process in a context leaves it exactly in the state that the process of the next context finds it. If this is satisfied, then the execution is valid and the $error$ state is reachable if and only if a bad state can be reached in this reduced SC program.
\section{Code-to-code translation for reduction to SC (for the complete model)}
\subsection{Scheme for the complete model (with synchronization included)}
Our translation scheme translates a program $Prog$ into a program $Prog^\clubsuit$ using the map function $\llbracket\cdot\rrbracket_K$. Let $\mathcal{P}$ and $\mathcal{X}$ be the set of processes and shared variables in our program. Then, the map $\llbracket\cdot\rrbracket_K$ replaces the variables of $Prog$ by $|\mathcal{P}|\cdot K$ copies of the set $\mathcal{X}$, along with a finite set of finite data structures defined below. Below, the function $\texttt{gen}$ takes in a finite set and returns a randomly chosen element of the set.\\
$$\llbracket Prog \rrbracket_K \myeq \texttt{ vars: }x^* \hspace{0.5em} \langle \texttt{addvars} \rangle_K$$
\vspace{-2em}
$$\qquad\qquad\qquad\qquad\kern 6.5em\texttt{procs: }(\llbracket p \rrbracket_K)^* \kern 0.5em \langle \texttt{initProc} \rangle_K \kern 0.5em \langle \texttt{verProc} \rangle_K$$
$$\llbracket p \rrbracket_K \myeq \;\texttt{regs: } \$r^*$$
\vspace{-2em}
$$\qquad\qquad\qquad\texttt{instrs: } (\llbracket i \rrbracket_K^p)^*$$
$$\llbracket i \rrbracket_K^p \myeq l: \kern 0.5em \langle \texttt{activeCnt} \rangle_K^p \kern 0.5em \llbracket \texttt{s} \rrbracket_K^p \kern 0.5em \langle \texttt{closeCnt} \rangle_K^p$$
$$\llbracket x \leftarrow exp \rrbracket_K^p \myeq \llbracket x \leftarrow exp \rrbracket_K^\texttt{p,Write}$$ 
\vspace{-1.2em}
$$\llbracket \$r \leftarrow x \rrbracket_K^p \myeq \llbracket \$r \leftarrow x \rrbracket_K^\texttt{p,Read}$$
\vspace{-1.2em}
$$\llbracket \$r \leftarrow exp \rrbracket_K^p \myeq \llbracket \$r \leftarrow exp \rrbracket_K^\texttt{p,Assign} $$
\vspace{-1.2em}
$$\llbracket [exp'] \leftarrow exp \rrbracket_K^p \myeq \llbracket [exp'] \leftarrow exp \rrbracket_K^\texttt{p,Write}$$
\vspace{-1.2em}
$$\llbracket \$r \leftarrow [exp] \rrbracket_K^p \myeq \llbracket \$r \leftarrow [exp] \rrbracket_K^\texttt{p,Read}$$
\vspace{-1.2em}
$$\llbracket \texttt{if } exp \texttt{ then }i^* \texttt{ else }i^* \rrbracket_K^p \myeq \texttt{if } exp \texttt{ then } (\llbracket i  \rrbracket_K^p)^* \texttt{ else } (\llbracket i \rrbracket_K^p)^*; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{while } exp \texttt{ do }i^* \rrbracket_K^p \myeq \texttt{while } exp \texttt{ do } (\llbracket i \rrbracket_K^p)^*; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{assume } exp \rrbracket_K^p \myeq \texttt{assume } exp ; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{assert } exp \rrbracket_K^p \myeq \texttt{assert } exp ; \kern 0.5em \langle \texttt{control} \rangle_K^p$$
\vspace{-1.2em}
$$\llbracket \texttt{acquire \$r} \leftarrow [exp] \rrbracket \myeq \llbracket \$r \leftarrow [exp] \rrbracket_K^\texttt{p,LAcq}$$
\vspace{-1.2em}
$$\llbracket \texttt{release [exp']} \leftarrow exp \rrbracket_K^p \myeq \llbracket [exp'] \leftarrow exp \rrbracket_K^\texttt{p,SRel}$$
\vspace{-1.2em}
$$\llbracket \texttt{dmb.ld} \rrbracket_K^p \myeq \llbracket \texttt{dmb.ld} \rrbracket_K^\texttt{p,DmbLd}$$
\vspace{-1.2em}
$$\llbracket \texttt{dmb.st} \rrbracket_K^p \myeq \llbracket \texttt{dmb.st} \rrbracket_K^\texttt{p,DmbSt}$$
\vspace{-1.2em}
$$\llbracket \texttt{dmb.sy} \rrbracket_K^p \myeq \llbracket \texttt{dmb.sy} \rrbracket_K^\texttt{p,DmbSy}$$
\vspace{-1.2em}
$$\llbracket \texttt{isb} \rrbracket_K^p \myeq \llbracket \texttt{isb} \rrbracket_K^\texttt{p,isb}$$
\vspace{-1.2em}
$$\llbracket\texttt{term}\rrbracket_K^p \myeq \texttt{term}$$
\vspace{-1.2em}
$$\langle \var{addvars} \rangle_K \myeq \mu(|\mathcal{X}|,K), \mu^{init}(|\mathcal{X}|,K), \nu(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \quad\var{iR}(|\mathcal{P}|,|\mathcal{X}|), \var{cR}(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \quad\var{iW}(|\mathcal{P}|,|\mathcal{X}|), \var{cW}(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \qquad\quad\var{iReg}(|\mathcal{P}|,|\mathcal{R}|), \var{cReg}(|\mathcal{P}|,|\mathcal{R}|),$$
$$ \quad\var{iL}(|\mathcal{P}|,|\mathcal{R}|), \var{cL}(|\mathcal{P}|,|\mathcal{R}|),$$
$$ \quad\var{iS}(|\mathcal{P}|,|\mathcal{X}|), \var{cS}(|\mathcal{P}|,|\mathcal{X}|),$$
$$ \qquad\;\var{cDY}(|\mathcal{P}|), \var{cDL}(|\mathcal{P}|),\var{cDS}(|\mathcal{P}|),$$
$$ \quad\;\var{ctrl}(|\mathcal{P}|), \var{active}(K), cnt$$
\vspace{-1.2em}
$$\langle \texttt{activeCnt} \rangle_K^p \myeq \texttt{assume}(\texttt{active}(\texttt{cnt}) = p)$$
\vspace{-1.2em}
$$\langle \texttt{closeCnt} \rangle_K^p \myeq cnt \leftarrow cnt + \texttt{gen}([0,\cdots,K-1]);$$
\vspace{-1.7em}
$$ \texttt{assume}(cnt \leq K)$$
\vspace{-1.2em}
$$ \langle \texttt{control} \rangle_K^p \myeq \texttt{ctrl}(p) \leftarrow \texttt{ctrl}(p) + \texttt{gen}(0,\cdots,K-1);$$
\vspace{-1.7em}
$$ \texttt{assume}(\texttt{ctrl}(p) \leq K)$$
\subsection{Additional data structures for the complete model}
We use all of the data structures described in the section of the simple model. \\
\ab{\var{isb} instuructions are not handled yet due to the doubt.}\\
Now, similar to the structures in section 10, we define the mappings
$$ \var{iL}: \mathcal{P} \times \mathcal{R} \mapsto [1,\cdots,K] $$
$$ \var{cL}: \mathcal{P} \times \mathcal{R} \mapsto [1,\cdots,K] $$
$$ \var{iS}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K] $$
$$ \var{cS}: \mathcal{P} \times \mathcal{X} \mapsto [1,\cdots,K] $$
$$ \var{cDY}: \mathcal{P} \mapsto [1,\cdots,K] $$
$$ \var{cDS}: \mathcal{P} \mapsto [1,\cdots,K] $$
$$ \var{cDL}: \mathcal{P} \mapsto [1,\cdots,K] $$
The first four describe, for each process-register or process-variable pair, the initializing and commiting contexts of the latest \var{LAcq} instruction that loads to, and the latest \var{SRel} instruction that stores from that register/to that variable. There is however one change that we must keep in mind: now the set $\mathcal{X}$ consists both of variables and addressable memory regions (as opposed to just variables). Also, noting that the predicates on \var{LAcq} or \var{SRel} that appear in our rules, such as \var{AllLAcqs}, are not about those to a particular variable but over all of them, it will be hepful to define for $p \in \mathcal{P}$:
$$ \var{iS}(p) = \var{max}_{x \in \mathcal{X}} \var{iS}(p,x)$$
We similarly define $\var{iL}(p)$, $\var{cL}(p)$ and $\var{cS}(p)$. With these structures defined, we now elaborate upon the components of the code-to-code translation above.
\subsection{The initializing process}
\begin{algorithm}[H]
  \SetAlgoLined
  \For{$p \in \mathcal{P} \wedge x \in \mathcal{X}$}{
    $\var{iR}(p,x) \gets 1$\; 
    $\var{iW}(p,x) \gets 1$\;
    $\var{cW}(p,x) \gets 1$\;
    $\var{cR}(p,x) \gets 1$\;
    $\nu(p,x) \gets 0$\;
    $\mu(p,x,1) \gets 0$\;
    \For{$k \in [2,\cdots,K]$}{
        $\mu^{init}(p,x,k) \gets \var{gen}(\mathcal D)$\;
        $\mu(p,x,k) \gets \mu^{init}(p,x,k)$\;
    }
  }
  \For{$p \in \mathcal{P}$}{
    $\var{ctrl}(p) \gets 1$\;
    $\var{cDY}(p) \gets 1; \var{cDS}(p) \gets 1; \var{cDL}(p) \gets 1$\;
    \For{$\$r \in \mathcal{R}$}{
        $\var{iL}(p,r) \gets 1; \var{cL}(p,r) \gets 1$\;
        $\var{iS}(p,r) \gets 1; \var{cS}(p,r) \gets 1$\;
    }
  }
  \For{$\$r \in \mathcal{R}$}{
    $\var{iReg}(p) \gets 1$\;
    $\var{cReg}(p) \gets 1$\;
  }
  \For{$k \in [1,\cdots,K]$}{
    $\var{active}(k) \gets \var{gen}([1,\cdots,K])$\;
  }
  $cnt \gets 1$\;
  \caption{Algorithm $\langle \var{initProc} \rangle_K$.}
\end{algorithm}
The algorithm is largely the same as before. We add statements that initialize the values of the new structures defined above to 1, at lines 14-18.
\subsection{Write Statements}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iW}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cW} \gets \var{cW}(p,x)$\;
  $\var{cW}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  //\var{Check}\\
  $\var{assume}(\var{iW}(p,x) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iW}(p,x)) = p)$\;
  $\var{assume}(\var{iW}(p,x) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{iW}(p,x))$\;
  $\var{assume}(\var{iW}(p,x) \geq \var{max}(\var{cDY}(p),\var{cDS}(p),\var{cDL}(p)))$\;
  $\var{assume}(\var{iW}(p,x) \geq \var{cL}(p))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{max}(\var{old-cW},\var{cReg}(exp),\var{cR}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\mu(x,\var{cW}(p,x)) \gets exp$\;
  $\nu(p,x) \gets exp$\;
  \caption{$\llbracket x \leftarrow exp\rrbracket_K^{p,\var{Write}}$}
\end{algorithm}
We explain only the changes here compared to the listing in section 10. We check for the rules \var{AllSyncs},\var{AllDmbLds} and \var{AllDmbSts} in line 10. In line 11 we verify that \var{AllLAcqs} holds.\\
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iW}(p,[exp']) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cW} \gets \var{cW}(p,[exp'])$\;
  $\var{cW}(p,[exp']) \gets \var{gen}([1,\cdots,K])$\;
  //\var{Check}\\
  $\var{assume}(\var{iW}(p,[exp']) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iW}(p,[exp'])) = p)$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{iReg}(exp'))$\;
  $\var{assume}(\var{cW}(p,[exp']) \geq \var{iW}(p,[exp']))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{max}(\var{cDY}(p),\var{cDS}(p),\var{cDL}(p)))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{cL}(p))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{max}(\var{old-cW},\var{cReg}(exp),\var{cReg}(exp'),\var{cR}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\mu(x,\var{cW}(p,[exp'])) \gets exp$\;
  $\nu(p,[exp']) \gets exp$\;
  \caption{$\llbracket [exp'] \leftarrow exp\rrbracket_K^{p,\var{Write}}$}
\end{algorithm}
The expansion of this component is similar to the last, with the difference that we need to take into account \var{addr} dependencies. Accordingly, the check inserted at line 9 and in line 13 make sure that the \var{addr} part of \var{InitCnd} and \var{CommitCnd} are satisfied, respectively. Other than that, this expansion is similar to the previous one.
%% ASSIGN INSTRUCTIONS?? %%
\subsection{Assign Instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iReg}(\$r) \gets \var{gen}([1,\cdots,K])$\;
  $\var{cReg}(\$r) \gets \var{gen}([1,\cdots,K])$\;
  //\var{Check}\\
  $\var{assume}(\var{iReg}(\$r) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iReg}(\$r)) = p)$\;
  $\var{assume}(\var{iReg}(\$r) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{iReg}(\$r) \geq \var{max}(\var{cDY}(p),\var{cDS}(p),\var{cDL}(p)))$\;
  $\var{assume}(\var{iReg}(\$r) \geq \var{cL}(p))$\;
  $\var{assume}(\var{active}(\var{cReg}(\$r)) = p)$\;
  $\var{assume}(\var{cReg}(\$r) \geq \var{iReg}(\$r))$\;
  $\var{assume}(\var{cReg}(\$r) \geq \var{max}(\var{cReg}(exp),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\$r \gets exp$\;
  \caption{$\llbracket \$r \leftarrow exp\rrbracket_K^{p,\var{Assign}}$}
\end{algorithm}
The algorithm is largely same as section 10. The changes are the ones we applied to write instructions as well: the rules \var{AllDmbLds}, \var{AllDmbSts} and \var{AllSyncs} constitute line 8, and line 9 expresses \var{AllLAcqs}.
\subsection{Read Instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iR}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cR} \gets \var{cR}(p,x)$\;
  $\var{cR}(p,x) \gets \var{gen}([1,\cdots,K])$\;
  $\var{iReg}(\$r) \gets \var{iR}(p,x)$\;
  $\var{cReg}(\$r) \gets \var{cR}(p,x)$\;
  //\var{Check}\\
  $\var{assume}(\var{iR}(p,x) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iR}(p,x)) = p)$\;
  $\var{assume}(\var{iR}(p,x) \geq \var{iW}(p,x))$\;
  $\var{assume}(\var{iR}(p,x) \geq \var{cDY}(p))$\;
  $\var{assume}(\var{iR}(p,x) \geq \var{cDL}(p))$\;
  $\var{assume}(\var{iR}(p,x) \geq \var{iL}(p))$\;
  $\var{assume}(\var{cR}(p,x) \geq \var{iR}(p,x))$\;
  $\var{assume}(\var{active}(\var{cR}(p,x)) = p)$\;
  $\var{assume}(\var{cR}(p,x) \geq \var{max}(\var{old-cR},\var{cW}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  \uIf{$\var{iR}(p,x) < \var{cW}(p,x)$}{
    $\$r \gets \nu(p,x)$\;
  }
  \Else{
    $\$r \gets \mu(x,\var{iR}(p,x))$\;
  }
  \caption{$\llbracket \$r \leftarrow x\rrbracket_K^{p,\var{Read}}$}
\end{algorithm}
There are two changes here as compared to section 10: the rules \var{AllDmbLds} and \var{AllLAcqInit} have been incorporated into the listing, in lines 11 and 12 respectively. Line 10 lists the \var{AllSyncs} predicate that appears in the \var{InitReadFrom...} rules. 
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iR}(p,[exp]) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cR} \gets \var{cR}(p,[exp])$\;
  $\var{cR}(p,[exp]) \gets \var{gen}([1,\cdots,K])$\;
  $\var{iReg}(\$r) \gets \var{iR}(p,[exp])$\;
  $\var{cReg}(\$r) \gets \var{cR}(p,[exp])$\;
  //\var{Check}\\
  $\var{assume}(\var{iR}(p,[exp]) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iR}(p,[exp])) = p)$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iW}(p,[exp]))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iReg}(exp)$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{cDY}(p))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{cDL}(p))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iL}(p))$\;
  $\var{assume}(\var{cR}(p,[exp]) \geq \var{iR}(p,[exp]))$\;
  $\var{assume}(\var{active}(\var{cR}(p,[exp])) = p)$\;
  $\var{assume}(\var{cR}(p,[exp]) \geq \var{max}(\var{old-cR},\var{cW}(p,[exp]),\var{cReg}(exp),\var{ctrl}(p))$\;
  //\var{Update}\\
  \uIf{$\var{iR}(p,x) < \var{cW}(p,[exp])$}{
    $\$r \gets \nu(p,[exp])$\;
  }
  \Else{
    $\$r \gets \mu(x,\var{iR}(p,[exp]))$\;
  }
  \caption{$\llbracket \$r \leftarrow [exp]\rrbracket_K^{p,\var{Read}}$}
\end{algorithm}
This algorithm is similar to the previous one. The one difference is the incorporation of \var{data}-order related predicates: line 11 ensures that the read is initialized no earlier than an address-supplying event is. Similarly the modification to line 17 expresses the part of \var{ComCnd} which needs the instruction to be committed no earlier than any instruction which supplies the addresss to it.
\subsection{Load Acquire instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iR}(p,[exp]) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cR} \gets \var{cR}(p,[exp])$\;
  $\var{cR}(p,[exp]) \gets \var{gen}([1,\cdots,K])$\;
  $\var{iReg}(\$r) \gets \var{iR}(p,[exp])$\;
  $\var{cReg}(\$r) \gets \var{cR}(p,[exp])$\;
  $\var{iL}(p,\$r) \gets \var{iR}(p,[exp])$\;
  $\var{cL}(p,\$r) \gets \var{cR}(p,[exp])$\;
  //\var{Check}\\
  $\var{assume}(\var{iR}(p,[exp]) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iR}(p,[exp])) = p)$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iW}(p,[exp]))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iReg}(exp)$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{cDY}(p))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{cDL}(p))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{iL}(p))$\;
  $\var{assume}(\var{iR}(p,[exp]) \geq \var{cS}(p))$\;
  $\var{assume}(\var{cR}(p,[exp]) \geq \var{iR}(p,[exp]))$\;
  $\var{assume}(\var{active}(\var{cR}(p,[exp])) = p)$\;
  $\var{assume}(\var{cR}(p,[exp]) \geq \var{max}(\var{old-cR},\var{cW}(p,[exp]),\var{cReg}(exp),\var{ctrl}(p))$\;
  //\var{Update}\\
  \uIf{$\var{iR}(p,x) < \var{cW}(p,[exp])$}{
    $\$r \gets \nu(p,[exp])$\;
  }
  \Else{
    $\$r \gets \mu(x,\var{iR}(p,[exp]))$\;
  }
  \caption{$\llbracket \$r \leftarrow [exp]\rrbracket_K^{p,\var{LAcq}}$}
\end{algorithm}
This is similar to the listing for load instructions (which are in the above section of read instructions). The one difference is the \var{AllSRels} predicate during \var{init} which shows up on line 15.
\subsection{Store Release Instructions}
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{iW}(p,[exp']) \gets \var{gen}([1,\cdots,K])$\;
  $\var{old-cW} \gets \var{cW}(p,[exp'])$\;
  $\var{cW}(p,[exp']) \gets \var{gen}([1,\cdots,K])$\;
  $\var{iS}(p,[exp']) \gets \var{iW}(p,[exp'])$\;
  $\var{cS}(p,[exp']) \gets \var{cW}(p,[exp'])$\;
  //\var{Check}\\
  $\var{assume}(\var{iW}(p,[exp']) \geq cnt)$\;
  $\var{assume}(\var{active}(\var{iW}(p,[exp'])) = p)$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{iReg}(exp))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{iReg}(exp'))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{max}(\var{cDY}(p),\var{cDS}(p),\var{cDL}(p)))$\;
  $\var{assume}(\var{iW}(p,[exp']) \geq \var{max}(\var{cS}(p),\var{cL}(p)))$\;
  \For{$x \in \mathcal{X}$}{
    $\var{assume}(\var{iW}(p,[exp']) \geq \var{max}(\var{cR}(p,x),\var{cW}(p,x)))$\;
  }
  $\var{assume}(\var{cW}(p,[exp']) \geq \var{iW}(p,[exp']))$\;
  $\var{assume}(\var{cW}(p,x) \geq \var{max}(\var{old-cW},\var{cReg}(exp),\var{cReg}(exp'),\var{cR}(p,x),\var{ctrl}(p))$\;
  //\var{Update}\\
  $\mu(x,\var{cW}(p,[exp'])) \gets exp$\;
  $\nu(p,[exp']) \gets exp$\;
  \caption{$\llbracket [exp'] \leftarrow exp\rrbracket_K^{p,\var{SRel}}$}
\end{algorithm}
Store Release Instructions have one extra condition as compared to normal store conditions. It is the \var{AllMem} predicate which requires \textit{all} \var{po}-preceeding instructions that access memory to have been committed. Hence we can do away with \var{AllLAcqInit} which is subsumed in this. This predicate is expressed in lines 13 through 16: line 13 enforces this for \var{LAcq}s and \var{SRel}s, while the loop enforces this for all non-release/acquire accesses to memory (which includes variables). Line 12 as usual expresses the \var{AllSyncs}, \var{AllDmbLds} and \var{AllDmbSts} predicates. 
\subsubsection{Barrier Instructions}
As mentioned before, we do not elaborate upon the expansion of \var{isb} as it is the same as that of \var{dmb.sy}; which is given below.\\
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{old-cDY} \gets \var{cDY}(p)$\;
  $\var{cDY}(p) \gets \var{gen}[1,\cdots,K]$\;
  //\var{Check}\\
  $\var{assume}(\var{cDY}(p) \geq cnt)$\;
  $\var{assume}(\var{cDY}(p) \geq \var{max}(\var{old-cDY},\var{cDL}(p),\var{cDS}(p),\var{cL}(p),\var{cS}(p),\var{ctrl}(p)))$\;
  \For{$x \in \mathcal{X}$}{
    $\var{assume}(\var{cDY}(p) \geq \var{max}(\var{cW}(p,x),\var{cR}(p,x)))$\;
  }
  \caption{$\llbracket \var{dmb.sy} \rrbracket_K^{p,\var{DmbSy}}$}
\end{algorithm}
We first guess the context in which the \var{dmb.sy} will be committed, and then run it through some sanity checks. The \var{AllBarriers} predicate is part of line 5. In the same line we also have part of the \var{AllMem} predicate, with the rest of it being in lines 6-8. Line 5 also ensures that all \var{po}-previous aci instructions have been committed.\\
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{cDL}(p) \gets \var{gen}[1,\cdots,K]$\;
  //\var{Check}\\
  $\var{assume}(\var{cDL}(p) \geq cnt)$\;
  $\var{assume}(\var{cDL}(p) \geq \var{max}(\var{cDY}(p),\var{cL}(p),\var{ctrl}(p))$\;
  \For{$x \in \mathcal{X}$}{
    $\var{assume}(\var{cDL}(p) \geq \var{cR}(p,x))$\;
  }
  \caption{$\llbracket \var{dmb.ld} \rrbracket_K^{p,\var{DmbLd}}$}
\end{algorithm}
Again, for a \var{dmb.ld} we first guess the committing context for it, in line 2. We then check that it does not commit earlier than the current context. Then, we run it through the \var{AllDmbSys} and \var{AllReads} predicates. The first is in line 4, and the second is split across line 4 and line 6. The $\var{ctrl}(p)$ comes from the \var{ComCnd} predicate in \var{ComDmbLd}.\\
\begin{algorithm}[H]
  \SetAlgoLined
  //\var{Guess}\\
  $\var{cDS}(p) \gets \var{gen}[1,\cdots,K]$\;
  //\var{Check}\\
  $\var{assume}(\var{cDS}(p) \geq cnt)$\;
  $\var{assume}(\var{cDS}(p) \geq \var{max}(\var{cDY}(p),\var{cS}(p),\var{ctrl}(p)))$\;
  \For{$x \in \mathcal{X}$}{
    $\var{assume}(\var{cDS}(p) \geq \var{max}(\var{cW}(p,x)))$\;
  }
  \caption{$\llbracket \var{dmb.st} \rrbracket_K^{p,\var{DmbSt}}$}
\end{algorithm}
We first guess the commiting context of the \var{dmb.st} and run it through some sanity checks: one that it does not commit earlier than the current context. \var{AllDmbSys} and \var{ComCnd} make their appearance on line 4. The predicate \var{AllWrites} is spread across line 4 and line 6.
\subsection{Verifying process}
\begin{algorithm}[H]
  \SetAlgoLined
  \For{$p \in \mathcal{P} \wedge x \in \mathcal{X} \wedge k \in [1,\cdots,K-1]$}{
    $\var{assume}(\mu(p,x,k) = \mu^{init}(p,x,k+1))$\;
  }
  \If{$l$ is reachable}{
    $error$\;
  }
  \caption{$\langle \var{verProc} \rangle_K$.}
\end{algorithm}
The verifying process is the same as in section 10: it simply ensures that each context leaves the global state in a consistent state for the next one.
\end{document}
% ASK: Since dmb.sy requires only all po-previous memory access instrs to be committed does that mean that assign instrs can be reordered with it?
% ASK: Assign instrs?
% ASK: isb only needs po-prev instrs to have a determined memory footprint [rules are written saying inited; fix them- TODO]. This means only fetch? Or what about r -> w -> isb where w is addr-dependent on r; would this require that r is init-ed before isb is committed?
% TODO: Lazy approach should not be too hard; global state is clearly defined. Try once eager approach is done.
